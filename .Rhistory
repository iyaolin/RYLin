#' @return vector, if a package is sucessfully loaded
#'
#' @examples
#' load_packages()
#'
#' @export
pkgs_default <- c(
'tidyverse',
'ggplot2',
'ggthemes',
'viridis',
'stringi',
'hrbrthemes',
'lubridate',
'DT',
'scales',
'magrittr',
# 'shiny',
# 'shinydashboard',
# 'shinythemes',
# 'leaflet',
# 'highcharter',
'Hmisc',
'RPresto',
'DBI',
'bit64',
'pool',
'devtools',
'data.table'
)
pkgs_vis <- c("grid", 'gridExtra', 'RColorBrewer', 'corrplot', 'ggforce', 'ggridges')
loadPackages <- function(pkgs = pkgs_default, install = TRUE){
if (install) {
packages_to_install = pkgs[!(pkgs %in% installed.packages()[, 1])]
if (length(packages_to_install) > 0) {
install.packages(packages_to_install)
}
}
sapply(pkgs, require, character.only = TRUE)
}
loadPackages(pkgs_vis)
data.table::merge
library(data.table)
library(data.table)
?merge
(dt1 <- data.table(A = letters[1:10], X = 1:10, key = "A"))
(dt2 <- data.table(A = letters[5:14], Y = 1:10, key = "A"))
merge(dt1, dt2)
d1 <- data.table(a=sample(rep(1:3,each=2)), z=1:6)
d2 <- data.table(a=2:0, z=10:12)
merge(d1, d2, by="a")
data.table::merge
data.table::fread()
data.table::update.dev.pkg(repo="https://gitlab.com/Rdatatable/data.table")
remove.packages("data.table")
install.packages("data.table", type = "source",
repos = "http://Rdatatable.github.io/data.table")
install.packages("data.table", type = "source", repos = "http://Rdatatable.github.io/data.table")
library(data.table)
data.table::getNumericRounding()
data.table::getNumericRounding(3)
data.table::setNumericRounding(3)
library('ggplot2') # visualization
library('ggthemes') # visualization
library('ggridges') # visualization
library('ggforce') # visualization
library('ggExtra') # visualization
library('scales') # visualization
library('grid') # visualisation
library('gridExtra') # visualisation
library('corrplot') # visualisation
library('VIM') # missing values
#suppressPackageStartupMessages(library(heatmaply)) # visualisation
library('dplyr') # data manipulation
library('tidyr') # data manipulation
library('readr') # data input
library('stringr') # string manipulation
library('forcats') # factor manipulation
library('modelr') # factor manipulation
library('randomForest') # classification
library('xgboost') # classification
library('ROCR') # model validation
install.packages('ggExtra')
install.packages('VIM')
install.packages("VIM")
library('ggplot2') # visualization
library('ggthemes') # visualization
library('ggridges') # visualization
library('ggforce') # visualization
library('ggExtra') # visualization
library('scales') # visualization
library('grid') # visualisation
library('gridExtra') # visualisation
library('corrplot') # visualisation
library('VIM') # missing values
#suppressPackageStartupMessages(library(heatmaply)) # visualisation
library('dplyr') # data manipulation
library('tidyr') # data manipulation
library('readr') # data input
library('stringr') # string manipulation
library('forcats') # factor manipulation
library('modelr') # factor manipulation
library('randomForest') # classification
library('xgboost') # classification
library("gdata")  ## for read.xls()
library("dplyr")
library("tidyr")
library("ggplot2")
p1 <- logs %>%
group_by(msno) %>%
summarise(ct = n()) %>%
mutate(ct = factor(ct)) %>%
inner_join(train, by = "msno") %>%
group_by(ct, is_churn) %>%
count() %>%
spread(is_churn, n, fill = 0) %>%
mutate(frac_churn = `1`/(`1`+`0`)*100,
lwr = get_binCI(`1`,(`1`+`0`))[[1]]*100,
upr = get_binCI(`1`,(`1`+`0`))[[2]]*100
)
logs
pkgs <- c("RCurl","jsonlite")
for (pkg in pkgs) {
if (! (pkg %in% rownames(installed.packages()))) { install.packages(pkg) }
}
# Now we download, install and initialize the H2O package for R.
install.packages("h2o", type="source", repos="http://h2o-release.s3.amazonaws.com/h2o/rel-wright/5/R")
# Finally, let's load H2O and start up an H2O cluster
library(h2o)
h2o.init()
memory.size()
gc()
memory.size()
sessionInfo()
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
# Note: A copy from Cookbook for R (http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/)
renderMultiPlot <-
function(...,
plotlist = NULL,
file,
cols = 1,
layout = NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots / cols)),
ncol = cols,
nrow = ceiling(numPlots / cols))
}
if (numPlots == 1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]],
vp = viewport(
layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col
))
}
}
}
# plotErrorBar ------------------------------------------------------------
# plotErrorBar : customized ggplot2 bar plot with error bar
plotErrorBar <- function(df, x, y) {
t <- df[, .N, keyby = .(vx = get(x),
vy = get(y))] %>%
dcast.data.table(vx ~ vy, value.var = "N") %>%
'['(, value := `1` / (`1` + `0`)) %>%
'['()
gd <-
t[, c('lwr', 'upr') := get_binCI(`1`, `1` + `0`), by = 1:nrow(t)][]
setnames(gd, old = 'vx', x)
p <- gd  %>%
ggplot(aes_string(x, 'value', fill = x)) +
geom_col() +
geom_errorbar(
aes(ymin = lwr, ymax = upr),
width = 0.3,
size = 0.7,
color = "gray30"
) +
theme_light() +
theme(legend.position = "none")
list(gd, p)
}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
# Note: A copy from Cookbook for R (http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/)
renderMultiPlot <-
function(...,
plotlist = NULL,
file,
cols = 1,
layout = NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots / cols)),
ncol = cols,
nrow = ceiling(numPlots / cols))
}
if (numPlots == 1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]],
vp = viewport(
layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col
))
}
}
}
# plotErrorBar ------------------------------------------------------------
# plotErrorBar : customized ggplot2 bar plot with error bar
plotErrorBar <- function(df, x, y) {
t <- df[, .N, keyby = .(vx = get(x),
vy = get(y))] %>%
dcast.data.table(vx ~ vy, value.var = "N") %>%
'['(, value := `1` / (`1` + `0`)) %>%
'['()
gd <-
t[, c('lwr', 'upr') := get_binCI(`1`, `1` + `0`), by = 1:nrow(t)][]
setnames(gd, old = 'vx', x)
p <- gd  %>%
ggplot(aes_string(x, 'value', fill = x)) +
geom_col() +
geom_errorbar(
aes(ymin = lwr, ymax = upr),
width = 0.3,
size = 0.7,
color = "gray30"
) +
theme_light() +
theme(legend.position = "none")
list(gd, p)
}
library(igraph)
g<-graph.empty(n=6, directed = FALSE)
g <- add.edges(g,c(1,2, 2,3, 1,3, 2,4, 4,5, 4,6, 5,6))
plot(g)
betw <- edge.betweenness(g)
betw
g
str(g)
g
g[[1]]
g[2]
g[1]
g[6]
library(igraph)
# let's generate two networks and merge them into one graph.
g2 <- barabasi.game(50, p=2, directed=F)
g1 <- watts.strogatz.game(1, size=100, nei=5, p=0.05)
g <- graph.union(g1,g2)
# let's remove multi-edges and loops
g <- simplify(g)
# let's see if we have communities here using the
# Grivan-Newman algorithm
# 1st we calculate the edge betweenness, merges, etc...
ebc <- edge.betweenness.community(g, directed=F)
# Now we have the merges/splits and we need to calculate the modularity
# for each merge for this we'll use a function that for each edge
# removed will create a second graph, check for its membership and use
# that membership to calculate the modularity
mods <- sapply(0:ecount(g), function(i){
g2 <- delete.edges(g, ebc$removed.edges[seq(length=i)])
cl <- clusters(g2)$membership
# March 13, 2014 - compute modularity on the original graph g
# (Thank you to Augustin Luna for detecting this typo) and not on the induced one g2.
modularity(g,cl)
})
# we can now plot all modularities
plot(mods, pch=20)
g2<-delete.edges(g, ebc$removed.edges[seq(length=which.max(mods)-1)])
V(g)$color=clusters(g2)$membership
# Let's choose a layout for the graph
g$layout <- layout.fruchterman.reingold
# plot it
plot(g, vertex.label=NA)
# if we wanted to use the fastgreedy.community agorithm we would do
fc <- fastgreedy.community(g)
com<-community.to.membership(g, fc$merges, steps= which.max(fc$modularity)-1)
V(g)$color <- com$membership+1
g$layout <- layout.fruchterman.reingold
plot(g, vertex.label=NA)
library(igraph)
layout(matrix(c(1,2,3,
4,5,6),nr = 2, byrow = T))
##########################################################
#经典的“Zachary 空手道俱乐部”（Zachary‟s Karate Club）社
#会网络[26]。20 世纪70 年代，Zachary 用了两年的时间观察美国一所大学的空手道
#俱乐部内部成员间关系网络。在Zachary 调查的过程中，该俱乐部的主管与校长因
#为是否提高俱乐部收费的问题产生了争执，导致该俱乐部最终分裂成了两个分别
#以主管与校长为核心的小俱乐部。就模块度优化而言，当前学者们已经广泛认为，
#该网络的最优划分是模块度Q=0.419 的4 个社团划分。
##########################################################
g <- graph.famous("Zachary")
##
#• Community structure in social and biological networks
# M. Girvan and M. E. J. Newman
#• New to version 0.6: FALSE
#• Directed edges: TRUE
#• Weighted edges: TRUE
#• Handles multiple components: TRUE
#• Runtime: |V||E|^2 ~稀疏:O(N^3)
##
system.time(ec <- edge.betweenness.community(g))
print(modularity(ec))
plot(ec, g)
#• Computing communities in large networks using random walks
# Pascal Pons, Matthieu Latapy
#• New to version 0.6: FALSE
#• Directed edges: FALSE
#• Weighted edges: TRUE
#• Handles multiple components: FALSE
#• Runtime: |E||V|^2
system.time(wc <- walktrap.community(g))
print(modularity(wc))
#membership(wc)
plot(wc , g)
#• Finding community structure in networks using the eigenvectors of matrices
# MEJ Newman
# Phys Rev E 74:036104 (2006)
#• New to version 0.6: FALSE
#• Directed edges: FALSE
#• Weighted edges: FALSE
#• Handles multiple components: TRUE
#• Runtime: c|V|^2 + |E| ~N(N^2)
system.time(lec <-leading.eigenvector.community(g))
print(modularity(lec))
plot(lec,g)
#• Finding community structure in very large networks
# Aaron Clauset, M. E. J. Newman, Cristopher Moore
#• Finding Community Structure in Mega-scale Social Networks
# Ken Wakita, Toshiyuki Tsurumi
#• New to version 0.6: FALSE
#• Directed edges: FALSE
#• Weighted edges: TRUE
#• Handles multiple components: TRUE
#• Runtime: |V||E| log |V|
system.time(fc <- fastgreedy.community(g))
print(modularity(fc))
plot(fc, g)
#• Fast unfolding of communities in large networks
# Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre
#• New to version 0.6: TRUE
#• Directed edges: FALSE
#• Weighted edges: TRUE
#• Handles multiple components: TRUE
# Runtime: “linear” when |V| \approx |E| ~ sparse; (a quick glance at the algorithm \
# suggests this would be quadratic for fully-connected graphs)
system.time(mc <- multilevel.community(g, weights=NA))
print(modularity(mc))
plot(mc, g)
#• Near linear time algorithm to detect community structures in large-scale networks.
# Raghavan, U.N. and Albert, R. and Kumara, S.
# Phys Rev E 76, 036106. (2007)
#• New to version 0.6: TRUE
#• Directed edges: FALSE
#• Weighted edges: TRUE
#• Handles multiple components: FALSE
# Runtime: |V| + |E|
system.time(lc <- label.propagation.community(g))
print(modularity(lc))
plot(lc , g)
library(repmis)
library(igraph)
test=source_data("https://www.dropbox.com/s/bochkedd4o3gzvq/so.csv?dl=0")
library(RYLin)
install.packages('repmis')
library(repmis)
test=source_data("https://www.dropbox.com/s/bochkedd4o3gzvq/so.csv?dl=0")
library(repmis)
library(igraph)
test=source_data("https://www.dropbox.com/s/bochkedd4o3gzvq/so.csv?dl=0")
memberships <- list()
### edge.betweenness.community
ebc <- edge.betweenness.community(G)
mods <- sapply(0:ecount(G), function(i) {
g2 <- delete.edges(G, ebc$removed.edges[seq(length=i)])
cl <- clusters(g2)$membership
modularity(G, cl)
})
g2 <- delete.edges(G, ebc$removed.edges[1:(which.max(mods)-1)])
memberships$`Edge betweenness` <- clusters(g2)$membership
### fastgreedy.community
fc <- fastgreedy.community(G)
memb <- community.to.membership(G, fc$merges,
steps=which.max(fc$modularity)-1)
memberships$`Fast greedy` <- memb$membership
### leading.eigenvector.community
lec <- leading.eigenvector.community(G)
memberships$`Leading eigenvector` <- lec$membership
### spinglass.community
sc <- spinglass.community(G, spins=10)
memberships$`Spinglass` <- sc$membership
### walktrap.community
wt <- walktrap.community(G, modularity=TRUE)
wmemb <- community.to.membership(G, wt$merges,
steps=which.max(wt$modularity)-1)
memberships$`Walktrap` <- wmemb$membership
### label.propagation.community
memberships$`Label propagation` <- label.propagation.community(G)
g <- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g <- add_edges(g, c(1,6, 1,11, 6, 11))
cluster_louvain(g)
make_full_graph(5)
spark_install(verbose = T)
library(rsparkling)
library(sparklyr)
library(h2o)
library(here)
library(glue)
install.packages('sparklyr')
library(sparklyr)
spark_install()
library(h2o)
h2o.init()
locate_source <- function(s) {
if (data_source_is_s3)
myPath <- paste0("s3n://h2o-public-test-data/", s)
else
myPath <- h2o:::.h2o.locate(s)
}
data_source_is_s3 <- FALSE
locate_source <- function(s) {
if (data_source_is_s3)
myPath <- paste0("s3n://h2o-public-test-data/", s)
else
myPath <- h2o:::.h2o.locate(s)
}
plot_scoring <- function(model) {
sh <- h2o.scoreHistory(object = model)
par(mfrow=c(1,2))
if(model@algorithm == "gbm" | model@algorithm == "drf"){
min <- min(range(sh$training_rmse), range(sh$validation_rmse))
max <- max(range(sh$training_rmse), range(sh$validation_rmse))
plot(x = sh$number_of_trees, y = sh$validation_rmse, col = "orange", main = model@model_id, ylim = c(min,max))
points(x = sh$number_of_trees, y = sh$training_rmse, col = "blue")
min <- min(range(sh$training_auc), range(sh$validation_auc))
max <- max(range(sh$training_auc), range(sh$validation_auc))
plot(x = sh$number_of_trees, y = sh$validation_auc, col = "orange", main = model@model_id, ylim = c(min,max))
points(x = sh$number_of_trees, y = sh$training_auc, col = "blue")
return(data.frame(number_of_trees = sh$number_of_trees, validation_auc = sh$validation_auc, validation_rmse = sh$validation_rmse))
}
if(model@algorithm == "deeplearning"){
plot(x = sh$epochs, y = sh$validation_rmse, col = "orange", main = model@model_id)
plot(x = sh$epochs, y = sh$validation_auc, col = "orange", main = model@model_id)
}
}
small_test <-  locate_source("bigdata/laptop/lending-club/LoanStats3a.csv")
data_source_is_s3 <- TRUE
myPath <- paste0("s3n://h2o-public-test-data/", s)
data_source_is_s3 <- TRUE
myPath <- paste0("s3n://h2o-public-test-data/", s)
small_test <-  locate_source("bigdata/laptop/lending-club/LoanStats3a.csv")
small_test
small_test <-  locate_source("bigdata/laptop/lending-club/LoanStats3a.csv")
big_test <-  c(locate_source("bigdata/laptop/lending-club/LoanStats3a.csv"),
locate_source("bigdata/laptop/lending-club/LoanStats3b.csv"),
locate_source("bigdata/laptop/lending-club/LoanStats3c.csv"),
locate_source("bigdata/laptop/lending-club/LoanStats3d.csv"))
print("Import approved loan requests for Lending Club...")
loanStats <- h2o.importFile(path = big_test, parse = F)
?
h2o.importFile
library(h2o)
localH2O = h2o.init()
demo(h2o.kmeans)
h2o.init()
library('h2o')
h2o.init()
